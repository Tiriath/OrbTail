#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../tesi.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Per la realizzazione di OrbTail ci si è serviti di un metodo di sviluppo
 a fasi.
 La fase preliminare si è concentrata sulla definizione delle tecnologie
 impiegate: l'attenta scelta di quest'ultime è di cruciale importanza per
 minimizzare l'impatto sul processo produttivo in caso di criticitá o limitazion
i, specie nelle fasi piú avanzate del progetto.
 Per permettere a piú sviluppatori di lavorare sul progetto in contemporanea,
 mantenere lo storico dei file di progetto e controllare lo sviluppo delle
 varie funzionalitá ci si è affidati a 
\emph on
git
\emph default
, un software per il 
\emph on
controllo di versione 
\emph default
distribuito.
 Per via degli interventi molto estesi che hanno visto la riscrittura quasi
 completa dei contributi originali, la 
\emph on
repository 
\emph default
del gioco risalente al 2013 è stata duplicata e il processo di sviluppo
 descritto in questo lavoro di tesi è proseguito su quest'ultima.
\end_layout

\begin_layout Standard
Un altro aspetto fondamentale riguarda la scelta del 
\emph on
motore grafico
\emph default
.
 Fin dalla versione originale era chiaro che sviluppare senza usare motori
 grafici di terze parti avrebbe aumentato esponenzialmente il tempi di sviluppo,
 rendendo di fatto impossibile supportare tutte le piattaforme desiderate.
 Sebbene oggi vi sia un gran numero di motori grafici gratuiti in grado
 di soddisfare la maggior parte delle esigenze, durante lo sviluppo della
 prima versione di OrbTail le scelte erano ben piú limitate.
 Le due tecnologie principali erano rappresentate da Unity 4.3 e UDK e, sebbene
 quest'ultimo garantiva un'ottima resa visiva, lo strumento risultava instabile,
 poco documentato e particolarmente macchinoso.
 Unity, d'altro canto, è sembrato fin da subito adatto agli scopi del progetto,
 specie per quanto riguarda il supporto dei dispositivi 
\emph on
mobile
\emph default
, ed in generale molto intuitivo.
 Considerando che per questo lavoro di tesi ci si aspettava la riscrittura
 della maggior parte del codice, è stata inoltre avanzata l'ipotesi di un
 cambio motore grafico a favore di Unreal Engine 4.
 Sebbene quest'ultimo avrebbe garantito un'eccellente resa grafica, l'idea
 è stata rapidamente accantonata per via delle iterazioni di sviluppo incredibil
mente piú lente che caratterizzano questo motore grafico, la mancanza di
 servizi di 
\emph on
matchmaking 
\emph default
e, soprattutto, delle criticitá riguardanti lo sviluppo su piattaforme 
\emph on
mobile
\emph default
 (specie in termini di prestazioni ed ottimizzazioni).
 Per questa nuova versione del titolo è stato pertanto deciso di aggiornare
 il motore grafico, passando da Unity 4.13 alla versione 2017.3, cercando
 di partire da una base quanto piú stabile possibile e proseguendo per iterazion
i successive.
\end_layout

\begin_layout Section
Unity
\end_layout

\begin_layout Standard
Unity è un motore grafico sviluppato da 
\emph on
Unity Technologies
\emph default
 che consente di sviluppare giochi multipiattaforma su tutte le pattaforme
 
\emph on
mobile
\emph default
, 
\emph on
console 
\emph default
e 
\emph on
desktop
\emph default
.
 La presenza di una versione gratuita unita ad un elevato grado di intuitivitá
 ne ha garantito la rapida affermazione da parte di sviluppatori 
\emph on
indipendenti
\emph default
 e non.
 Questo motore è caratterizzato da paradigmi di sviluppo molto chiari, il
 che lo rende tanto adatto agli sviluppatori alla prime armi quanto ai piú
 esperti.
 Il 
\emph on
pattern architetturale
\emph default
 principale, rappresentato dal
\emph on
l'entity-component
\emph default
, consiste nell'implementare funzionalitá autoconclusive all'interno di
 
\emph on
componenti 
\emph default
indipendenti ed usare i 
\emph on
game object 
\emph default
(termine usato da Unity per descrivere le 
\emph on
entitá
\emph default
)
\emph on
 
\emph default
come aggregatori di quest'ultimi al fine di modellare comportamenti piú
 complessi.
 Questo paradigma è stato migliorato nella versione del motore del 2018,
 introducendo il concetto di 
\emph on
system
\emph default
.
 Secondo questa variante, i componenti espongono solo dei dati e le logiche
 sono implementate all'interno dei sistemi, garantendo un disaccoppiamento
 ancora piú forte tra le varie componenti del gioco.
 Unity consente di implementare le logiche di gioco tramite script 
\emph on
C# 
\emph default
o 
\emph on
Javascript 
\emph default
e 
\emph on
shader 
\emph default
personalizzati tramite il linguaggio CG.
 L'assenza completa di codice nativo, ad eccezione del 
\emph on
core
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Il 
\emph on
core 
\emph default
di un motore grafico è il modulo software di piú basso livello.
 Esso si occupa di astrarre le funzionalitá specifiche di ciascuna piattaforma
 e di dettare il flusso di esecuzione di tutti gli altri sottosistemi, quali
 il renderer, il motore fisico, la logica di gioco e la gestione della memoria.
\end_layout

\end_inset


\emph default
, rende le iterazioni di sviluppo incredibilmente veloci in quanto non esiste
 un processo apposito di compilazione.
\end_layout

\begin_layout Standard
La limitazione maggiore di questo engine risiede nel fatto che il suo 
\emph on
core 
\emph default
è completamente 
\emph on
closed-source 
\emph default
(a meno di non pagare per ottenerne l'accesso) e ció impedisce agli sviluppatori
 di poterne analizzare il flusso di esecuzione, rendendo particolarmente
 difficile il processo di 
\emph on
debugging.
 
\emph default
Questa limitazione è stata mitigata durante il primo trimestre del 2018,
 quando Unity Technologies ne ha reso pubblico il codice sorgente C# su
 
\emph on
bitbucket
\begin_inset CommandInset citation
LatexCommand cite
key "UnityCSharp"

\end_inset

.
 
\emph default
Nonostante il rilascio del codice sia un notevole passo avanti, permane
 ancora l'impossibilitá di modificare il codice del motore per adattarlo
 meglio alle proprie esigenze e ció richiede talvolta l'impiego di soluzioni
 temporanee o alternative.
\end_layout

\begin_layout Standard
Per lo sviluppo di OrbTail sono state usate prevalentemente funzionalitá
 di base legate al 3D, al motore fisico, alla gestione delle scene e delle
 funzionalitá di rete.
 L'uso di funzionalitá generiche ha permesso di evitare tutte le problematiche
 legate ai sistemi piú specifici, quali gestione del 2D e delle 
\emph on
nav mesh 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Le 
\emph on
nav-mesh 
\emph default
(in italiano 
\begin_inset Quotes fld
\end_inset

mesh di navigazione
\begin_inset Quotes frd
\end_inset

) sono delle superfici poligonali solitamente usate dal sistema di 
\emph on
intelligenza artificiale 
\emph default
per determinare il percorso ottimo (o subottimo) tra due punti nello spazio.
\end_layout

\end_inset

, 
\emph default
le quali si sono talvolta dimostrate inaffidabili, limitate o afflitte da
 bug nascosti.
 L'intero codice sorgente del gioco è stato sviluppato in C#, utilizzando
 il paradigma 
\emph on
entity-component
\emph default
.
 L'integrazione del pattern 
\emph on
entity-component-system 
\emph default
è stata evitata in quanto questi risultava ancora in fase sperimentale e
 per via del fatto che lo sviluppo del gioco era giá in fase avanzata e
 si voleva evitare di correre 
\emph on
rischi
\emph default
 inutili.
 L'architettura di gioco sfrutta inoltre molti oggetti 
\emph on
manager
\emph default
 al fine di scambiare informazioni tra piú livelli e per fornire un unico
 punto d'accesso ai vari sottosistemi.
 Un manager è un'
\emph on
entitá
\emph default
 di gioco che funge da 
\emph on
singleton
\emph default
 accessibile da tutti gli altri sottosistemi al fine di leggerne o modificarne
 lo stato.
 
\end_layout

\begin_layout Standard
L'uso dell'apposito strumento di aggiornamento di versione fornito dal motore
 si è rivelato di notevole importanza, in quanto ha permesso fin da subito
 di ottenere un prodotto stabile a partire dalla versione originale del
 2013.
 Al termine del processo di 
\emph on
porting 
\emph default
automatico, il gioco ha preservato 
\emph on
tutte 
\emph default
le funzionalitá, comprese quelle legate alla rete, al 
\emph on
matchmaking
\emph default
 e al 
\emph on
cross-platform play 
\emph default
manifestando problematiche minori dovuto all'uso di 
\emph on
API 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Col termine
\emph on
 API, 
\emph default
acronimo di 
\emph on
application programming interface, 
\emph default
ci si riferisce a tutte quelle funzionalitá di un sistema rese disponibili
 agli sviluppatori tramite opportune 
\emph on
procedure
\emph default
.
\end_layout

\end_inset

 
\emph default
obsolete (principalmente in ambito 
\emph on
UI 
\emph default
e di gestione dei livelli).
 Una volta ottenuta una versione stabile, sono state infine aggiornate tutte
 le funzionalitá superate sostituendole con le nuove varianti messe a disposizio
ne del motore.
 Al termine di questa fase ci si è concentrati sull'aggiornamento dell'architett
ura del gioco e sull'implementazione delle nuove funzionalitá.
\end_layout

\begin_layout Subsection
Plug-in
\end_layout

\begin_layout Standard
Unity mette a disposizione un gran quantitativo di 
\emph on
plug-in 
\emph default
esterni al fine di aumentare la resa dei giochi, semplificare il processo
 di sviluppo o aggiungere nuove funzionalitá.
 Per lo sviluppo di OrbTail è stato deciso di utilizzarne uno solo
\emph on
 
\emph default
dal nome 
\emph on
iTween
\begin_inset CommandInset citation
LatexCommand cite
key "iTween"

\end_inset

.
 
\emph default
Questo plug-in gratuito è usato per gestire in maniera semplice ed automatica
 il processo di 
\emph on
tweening
\emph default
, ovvero l'interpolazione automatica di valori in un certo periodo di tempo
 attraverso il sistema di 
\emph on
coroutine 
\emph default
di C#.
 Il plug-in è stato utilizzato principalmente per aggiungere animazioni
 agli elementi dell'interfaccia grafica ed in misura molto minore per gli
 elementi di gioco 3D.
 L'uso di questo sistema ha permesso di risparmiare un notevole quantitativo
 di tempo, garantendo una resa visiva molto buona.
 Quest'ultimo si presenta come un unico file monolitico che puó essere integrato
 nel progetto e non richiede alcuna forma di configurazione.
 Nella fase di 
\emph on
porting 
\emph default
è stato necessario aggiornare il plug-in alla versione piú recente.
\end_layout

\begin_layout Section
Meccaniche di base
\end_layout

\begin_layout Standard
La prima fase dello sviluppo di OrbTail si concentra sulla definizione dell'arch
itettura generale del gioco ed in particolar modo delle meccaniche di base.
 Quest'ultime sono condivise tra tutte le modalitá e livelli e pertanto
 sono state pensate per essere completamente indipendenti da essi.
 Tra le meccaniche di base troviamo la gestione della gravitá, del sistema
 di controllo dei veicoli, della gestione degli oggetti collezionabili e
 degli impatti.
 Tutte le funzionalitá qui descritte sono state sviluppate in una mappa
 di test apposita, con risorse grafiche temporanee e gestione degli input
 molto basilare.
\end_layout

\begin_layout Subsection
Gestione della gravitá
\end_layout

\begin_layout Standard
I livelli offerti dal gioco sono caratterizzati da topologie profondamente
 diverse, il che rende impossibile utilizzare la gravitá automatica fornita
 dal motore fisico di Unity per far fluttuare gli oggetti su di essi.
 Durante la prima iterazione ci si è affidati al sistema di 
\emph on
raycasting 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Il 
\emph on
raycasting 
\emph default
è una tecnica che consente di determinare le intersezioni tra un raggio
 descritto da un punto inziale ed una direzione ed una o piú superfici poligonal
i.
\end_layout

\end_inset

 
\emph default
al fine di individuare un punto sulla superficie del livello da usare come
 base per il calcolo, tuttavia ci si è presto accorti che il sistema era
 affetto da gravi difetti.
 Sebbene l'uso del 
\emph on
raycast 
\emph default
permette di scrivere un codice di gestione unico che si adatta a tutte le
 topologie, determinare la direzione del raggio usando solo l'orientamento
 dell'oggetto puó generare risultati ambigui o imprevedibili.
 Queste problematiche sono esacerbate da rapidi cambi di direzione a seguito
 di esplosioni o durante il normale 
\emph on
rollio 
\emph default
degli oggetti lungo la superficie del livello.
 Per risolvere questa ambiguitá ci si è affidati ad una descrizione 
\emph on
analitica 
\emph default
della forza di gravitá per ciascuna delle topologie supportate.
 Il 
\emph on
campo gravitazionale
\emph default
 cosí descritto consente di ottenere una direzione non ambigua in cui effettuare
 il 
\emph on
raycasting
\emph default
 per ogni punto dello spazio.
 Una volta individuato il punto sulla superficie, una semplice simulazione
 di un 
\emph on
moto oscillatorio smorzato 
\emph default
permette di modellare lo stazionamento degli oggetti sull'arena.
\end_layout

\begin_layout Standard
La soluzione adottata prevede l'uso di due elementi principali: un componente
 base 
\emph on
GravityField, 
\emph default
da cui derivano le diverse descrizioni dei campi di gravitá supportati,
\emph on
 
\emph default
e il 
\emph on
FloatingObject 
\emph default
che, assegnato agli oggetti di gioco, consente loro di fluttuare sull'arena.
 (Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OrbTailGravity"

\end_inset

).
\begin_inset Float figure
placement !h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename C:/Users/raffa/Documents/Repo/OrbTail/Doc/Tesi/img/dev_gravity.jpg
	lyxscale 20
	height 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Gestione della gravitá.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:OrbTailGravity"

\end_inset

UML Gestione della gravitá.
\end_layout

\end_inset


\end_layout

\end_inset

 Il primo di questi viene assegnato all'arena e consente di configurare
 sia l'intensitá della gravitá e sia la distanza di stazionamento degli
 oggetti rispetto alla superficie per impedire che questi possano compenetravi.
 Il secondo si occupa di simulare lo stazionamento dell'oggetto a partire
 dalla direzione della forza di gravitá.
\end_layout

\begin_layout Subsection
Sistema di controllo
\end_layout

\begin_layout Standard
Il sistema di controllo di ciascun veicolo si occupa di gestire il movimento
 di quest'ultimo all'interno dell'arena considerando la direzione della
 forza di gravitá e l'input dell'utente.
\end_layout

\begin_layout Standard
Il componente 
\emph on
MovementController
\emph default
 determina la velocitá lineare e quella angolare del veicolo in ogni istante
 e applica opportune forze al 
\emph on
corpo rigido 
\emph default
di quest'ultimo per causarne il movimento fisico.
 La gestione del movimento non è simulata in maniera fisicamente accurata,
 bensí è affidata ad un semplice controllore 
\emph on
PID.
 
\emph default
Il sistema adoperato consente di controllare la velocitá da applicare 
\begin_inset Formula $u(t)$
\end_inset

 in funzione di quella attuale del veicolo 
\begin_inset Formula $y(t)$
\end_inset

 e di quella desiderata 
\begin_inset Formula $r(t)$
\end_inset

 usando la sola azione di controllo 
\emph on
proporzionale 
\emph default
con costante 
\begin_inset Formula $K_{p}$
\end_inset

.
 Un controllore analogo è utilizzato per gestire l'azione di sterzo e la
 velocitá angolare risultate.
 Per questa particolare implementazione le azioni 
\emph on
integrali 
\emph default
e 
\emph on
derivative 
\emph default
non sono state ritenute necessarie:
\begin_inset Formula 
\[
u(t)=K_{p}(r(t)-y(t))
\]

\end_inset


\end_layout

\begin_layout Standard
La velocitá desiderata 
\begin_inset Formula $r(t)$
\end_inset

 è determinata dal valore massimo di 
\emph on
velocitá 
\emph default
del veicolo 
\begin_inset Formula $r_{max}>0$
\end_inset

 e dall'input dell'utente 
\begin_inset Formula $r_{in}\in[-1;+1]$
\end_inset

.
 Il termine proporzionale 
\begin_inset Formula $K_{e}$
\end_inset

 è invece proporzionale al suo parametro di 
\emph on
accelerazione
\emph default
.
 L'azione di sterzo segue un principio identico ma ha costanti che dipendono
 dalla 
\emph on
manovrabilitá 
\emph default
del veicolo (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Veicoli"

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
r(t)=r_{max}\cdot r_{in}
\]

\end_inset


\end_layout

\begin_layout Standard
La direzione di accelerazione è ricavata tramite il componente 
\emph on
FloatingObject
\emph default
 in funzione della tangente del campo di gravitá e della rotazione del veicolo,
 e ció impedisce che quest'ultimo possa percorrere la superficie del livello
 passandovici attraverso.
\end_layout

\begin_layout Subsection
Gestione dei collezionabili
\end_layout

\begin_layout Standard
La gestione della collezione degli elementi di gioco è affidata a tre componenti
 fondamentali.
 Il primo di questi, il 
\emph on
ProximityHandler
\emph default
, rappresenta un 
\emph on
volume di collisione sferico 
\emph default
attorno al veicolo il quale lancia un'opportuno evento quando un 
\emph on
orb 
\emph default
vi compenetra.
 Questo componente fa parte del 
\emph on
game object 
\emph default
che rappresenta il veicolo, assieme ad un ulteriore componente 
\emph on
Ship 
\emph default
che si preoccupa di gestire le logiche di base della coda, quali aggiungere
 o rimuoverne elementi.
 Il collegamento tra diversi 
\emph on
orb
\emph default
 è gestito attraverso un 
\emph on
vincolo fisico 
\emph default
di tipo molla, con una lunghezza massima tale per cui questi possano muoversi
 liberamente senza peró allontanarsi da quello che li precede nella coda.
 Una volta rimossi dalla coda, il vincolo fisico viene rimosso e l'
\emph on
orb 
\emph default
viene proiettato in una direzione casuale al fine di allontanarlo dal veicolo.
 Il 
\emph on
game object 
\emph default
che rappresenta ciascun 
\emph on
orb 
\emph default
usa il componente 
\emph on
FloatingObject 
\emph default
al fine di fluttuare sull'arena e un altro componente, l'
\emph on
OrbController
\emph default
, al fine di gestire i vincoli fisici di cui sopra.
\end_layout

\begin_layout Subsection
Gestione degli impatti
\end_layout

\begin_layout Standard
Il sistema di gestione degli scontri tra veicoli é implementato attraverso
 un componente 
\emph on
FightController, 
\emph default
il cui scopo é quello di rilevare gli impatti e notificare il componente
 
\emph on
Ship 
\emph default
del numero di 
\emph on
orb 
\emph default
persi come conseguenza.
 Le collisioni tra veicoli sono gestite direttamente dal motore fisico di
 Unity.
 Nella versione originale ciascuno di essi aveva uno o piú 
\emph on
collisori fisici 
\emph default
che approssimavano piú o meno precisamente la loro topologia, tuttavia questo
 approccio causava comportamenti inaspettati durante la risoluzione delle
 collisioni quali veicoli che si incastravano tra loro oppure la generazione
 di impulsi fisici di entitá molto elevata che causavano la perdita di tutti
 gli 
\emph on
orb
\emph default
 disponibili.
 Al fine di non avvantaggiare nessun veicolo ed evitare queste problematiche,
 nell'ultima versione ci si é affidati all'uso di un 
\emph on
collisore sferico 
\emph default
unico che approssima la superficie del veicolo racchiudendone il modello
 grafico.
 La forma e la dimensione del collisore é identica per tutti i veicoli e
 ció garantisce un'elevata consistenza durante la risoluzione degli scontri.
 Una volta rilevata una collisione durante quest'ultimi, il motore fisico
 genera una coppia di eventi, uno per ogni componente coinvolto nell'impatto.
 Ciascun 
\emph on
FightController 
\emph default
reagisce a questi eventi, determinando il numero di 
\emph on
orb 
\emph default
persi a causa dello scontro e lasciando al 
\emph on
FightController 
\emph default
del veicolo avversario il compito di staccare 
\emph on
orb 
\emph default
dal proprio.
\end_layout

\begin_layout Standard
Il numero di 
\emph on
orb 
\emph default
persi durante uno scontro dipende dalla direzione d'impatto e l'orientamento
 dei veicoli coinvolti: uno scontro frontale deve causare un distacco di
 
\emph on
orb 
\emph default
da parte di entrambi i veicoli, laddove colpire un veicolo su una fiancata
 non deve penalizzare in alcun modo l'aggressore.
\end_layout

\begin_layout Standard
Sia 
\begin_inset Formula $p$
\end_inset

 la posizione del veicolo sui cui viene generato l'evento di collisione,
 
\begin_inset Formula $f$
\end_inset

 la direzione di quest'ultimo, 
\begin_inset Formula $c$
\end_inset

 il punto di impatto trai veicoli convolti e 
\begin_inset Formula $v_{rel}$
\end_inset

 la velocitá relativa del veicolo rispetto all'avversario, la formula usata
 per determinare il numero di 
\emph on
danni 
\emph default
inflitti 
\begin_inset Formula $d$
\end_inset

 é la seguente:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
i_{d}=\frac{c-p}{|c-p|}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
i_{s}=\max(0,i_{d}\cdot f)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d=|v_{rel}|\cdot i_{s}\cdot off
\]

\end_inset


\end_layout

\begin_layout Standard
Il termine 
\begin_inset Formula $i_{d}$
\end_inset

 rappresenta la 
\emph on
direzione relativa di impatto
\emph default
, 
\begin_inset Formula $i_{s}$
\end_inset

 é invece un fattore di scala che impedisce ai veicoli di causare danni
 al di fuori di un cono frontale.
 Il numero di 
\emph on
orb
\emph default
 
\begin_inset Formula $o_{imp}$
\end_inset

 persi dal veicolo a seguito dell'impatto é calcolato come segue:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
o_{imp}=\lfloor d\cdot def^{-1}\rfloor
\]

\end_inset


\end_layout

\begin_layout Standard
I termini 
\begin_inset Formula $off$
\end_inset

 e 
\begin_inset Formula $def$
\end_inset

 sono due parametri che identificano il potere offensivo e quello difensivo
 di ciascun veicolo.
 Un tempo differenziati per veicolo, questi parametri sono oggi usati per
 rimappare il valore del danno causato e ricavare il numero di 
\emph on
orb 
\emph default
perduti e sono uguali per tutti.
\end_layout

\begin_layout Section
Architettura di rete
\end_layout

\begin_layout Standard
L'intera architettura di OrbTail é pensata per gestire in maniera indipendente
 client e server, partite multiplayer e single player.
\end_layout

\begin_layout Standard
Il sistema di rete di networking di orbtail si basa su un'architettura client
 sever, in cui uno dei dispositivi dei giocatori é usato come host per la
 partita.
 Questa scelta permette di risparmiare i costi dovuti alla gestione di un
 server esterno ed in ogni caso costituisce una soluzione piú che adeguata
 per un numero molto limitato di giocatori in partita.
\end_layout

\begin_layout Standard
Il sistema di rete é gestito attraverso dei componenti messi a disposizione
 dal motore grafico e si basa sui servizi di rete di unity.
 Questi servizi esterni sono usati per effettuare il matchmaking automatico
 delle partite tra piú giocatori.
 Logicamente ci sono due fasi di gioco che coinvolgono l'online, la fase
 di lobby e quella di gara.
 La classe principale é costituita dal LobbyManager, il quale, derivato
 dalla classe di Unity base NetworkLobbyManager consente di gestire in maniera
 automatizzata la riceca delle lobby di gioco, il matchmaking con altri
 giocatori e la gestione della connesioni alle lobby.
 L'intero sistema di lobby di Unity si basa sulla dicotomia Game Player
 e Lobby Player.
 Il primo é un game object che rappresenta la volontá del giocatore all'interno
 della lobby.
 Questo oggetto é replicato su tutti i client che partecipano alla partita
 e consente di mandare comandi al server.
 Il GamePlayer é un oggetto che invece rappresenta la volontá del giocatore
 in fase di gioco effettivo.
 La gestione della rete di Unity si basa sul concetto di server autoritativo,
 dove il server riceve i comandi dai giocatori e determina lo stato di gioco.
 La sincronizzazione degli elementi di gioco é basata su due meccanismi,
 la replicazione e le chiamate remote.
 Il primo meccanismo consente a due oggetti su istanze di gioco diverse
 di sincronizzare lo stato in maniera costante.
 Unity si preoccupa di propagare tutte le modifiche che vengono eseguite
 sul server su tutti i client.
 La propagazione di queste informazioni non puó avvenire in senso opposto.
 Il secondo meccanismo, RPC (remote procedure call) consente di chiamare
 un metodo su un'istanza remota di gioco.
 Esistono due varianti, le prime sono i comandi e servono per inviare un'azione
 dal client al server, le seconde sono le clientRpc e vengono inviate dal
 server su tutte le copie client.
 Il paradigma fondamentale consiste nell'inviare comandi dal client al server,
 attenere che questo ne verifichi la validitá ed aggiorni lo stato di gioco
 e quindi replicare lo stato di gioco su tutti i client come conseguenza
 per sincronizzarli tra loro.
 Il sistema di replicazione viene invece usato per sincronizzare valori
 che variano rapidamente nel tempo e che generalmente non hanno bisogno
 di chiamate esplicite, come ad esempio la posizione e la rotazione di ciascun
 veicolo.
 
\end_layout

\begin_layout Standard
Network spawnare per spawnare gli oggetti replicati sulla rete, non é possibile
 replicare oggetti giá posati in scena.
\end_layout

\begin_layout Subsection
Gestione della lobby
\end_layout

\begin_layout Standard
Il giocatore che possiede la lobby crea la configurazione di gioco.
 La configurazione viene serializzata tramite una stringa che codifica tutti
 gli aspetti salienti ed é usata come nome della partita.
 Limitazioni delle informazioni extra per ogni match.
 Se chi ha creato il match non ha specificato una modalitá o un livello,
 ne viene configurato uno a caso.
\end_layout

\begin_layout Standard
Una volta in lobby l'applicazione si basa sui servizi di matchmaking di
 unity al fine di individuare una partita con i criteri specificati dai
 giocatori (quali arena e modalitá), se viene individuata una partita coi
 criteri prestabiliti il giocatore ne prende parte, altrimenti viene creata
 una nuova lobby online a cui altri giocatori possono accedervi.
 Una volta connesso ad una lobby, il sistema provvede a generare un LobbyPlayer
 per il giocatore ed eventualmente replicarne una copia su tutti gli altri
 i client attualmente in partita.
 Il lobbyplayer contiene le informazioni relative al giocatore, quale ad
 esempio il suo indice all'interno della partita e il veicolo scelto.
 In questa fase il lobby player puó dichiarare al server di essere pronto.
 Una volta che il server determina che tutti i giocatori in partita sono
 pronti, il resto degli slot di partita sono riempiti da intelligenze artificial
i e tutti i client sono istruiti di caricare il livello corretto.
 In questa fase é previsto che i giocatori possano abbandonare la partita
 nella lobby, il server se ne accorge e li rimuove, liberando un posto libero
 per altri giocatori.
\end_layout

\begin_layout Subsection
Gestione della partita
\end_layout

\begin_layout Standard
Timer gestiti componenti particolari che hanno uno stato sincronizzato ma
 possono avanzare indipendentemente, permette di avere un countdown credibile
 anche in presenza di lag.
\end_layout

\begin_layout Standard
I game mode tengono traccia dei punteggi dei giocatori, nella modalitá longest
 tail ed elimination il punteggio é dato dalla lunghezza della coda.
 L'elimination game mode si mette in ascolto dell'evento di distruzione
 del giocatore e ne abilitá la modalitá spettatore e attacca gli orb a tutti
 i veicoli in fase di inizio partita.
\end_layout

\begin_layout Standard
Gestione scontri gestita sul server, il FightController sul client non fa
 assolutamente nulla.
 Il MovementController legge gli input solo sul client.
 Il client ha autoritá sulla posizione dei propri oggetti.
 Lo Ship usa le chiamate ClientRPC per attaccare e staccare gli orb da tutti
 i veicoli dei giocatori.
\end_layout

\begin_layout Standard
Una volta inziata la partita il gestore della lobby si preoccupa di rimpiazzare
 il vecchio LobbyPlayer con il GamePlayer, un game object che rappresenta
 effettivamente il veicolo utilizzato dal giocatore.
 Una volta in partita e necessario aspettare che tutti i giocatori nella
 partita siano pronti, questa fase di attesa é subdolamente mascherata dalla
 somministrazione di un tutorial che puó essere congedato.
 La gestione degli eventi di gioco importanti quali il collezionamento o
 la perdita di orb oppure l'acquisizione o l'uso di poteri é gestita direttament
e dal server e i client ne subiscono passivamente gli esiti.
\end_layout

\begin_layout Standard
I game mode servono per gestire le diverse condizioni di vittoria, e contengono
 tutte le informazioni riguardanti la partita (quanto dura il match, la
 durata del countdown, e altre configurazioni specifiche).
 Gestire le logiche condivise tra le varie modalitá, tipo gli stati e consente
 id essere esteso con le regole specifiche dei game modi concreti.
 Il game mode viene creato e configurato dal giocatore che possiede la partita
 durante la lobby e mantenuto in vita durante la fase di gara.
\end_layout

\begin_layout Standard
Ciascuna partita é suddivisa in diverse fasi, fase di sincronizzazione (in
 cui si vede il tutorial), fase di countdown in cui i partecipanti attendono
 che la partita inizi, la fase di gioco caratterizzata da un timer e la
 fase finale che é triggerata da condizioni in funzione del game mode.
 Lo stato del game mode é sincronizzato tra tutti i client e la sua modifica
 scatena eventi locali su ogni client in modo che tutti gli oggetti interessati
 come ad esempio la HUD possano reagire (creando la HUD, aggiornando i contatori
 e cosí via).
\end_layout

\begin_layout Section
Potenziamenti
\end_layout

\begin_layout Standard
Gestione dei potenziamenti con riguardo per la parte online e di sincronizzazion
e.
\end_layout

\begin_layout Section
Intelligenza artificiale
\end_layout

\begin_layout Section
Splitscreen
\end_layout

\begin_layout Section
Gestione degli input
\end_layout

\begin_layout Section
Menú
\end_layout

\end_body
\end_document
