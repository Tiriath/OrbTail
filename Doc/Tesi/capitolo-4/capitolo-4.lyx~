#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../tesi.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Per la realizzazione di OrbTail ci si é serviti di un metodo di sviluppo
 a fasi.
 La fase preliminare si é concentrata sulla definizione delle tecnologie
 impiegate: l'attenta scelta di quest'ultime é di cruciale importanza per
 minimizzare l'impatto sul processo produttivo in caso di criticitá o limitazion
i, specie nelle fasi piú avanzate del progetto.
 Per permettere a piú sviluppatori di lavorare sul progetto in contemporanea,
 mantenere lo storico dei file di progetto e controllare lo sviluppo delle
 varie funzionalitá ci si é affidati a 
\emph on
git
\emph default
, un software per il 
\emph on
controllo di versione 
\emph default
distribuito.
 Per via degli interventi molto estesi che hanno visto la riscrittura quasi
 completa dei contributi originali, la 
\emph on
repository 
\emph default
del gioco risalente al 2013 é stata duplicata e il processo di sviluppo
 descritto in questo lavoro di tesi é proseguito su quest'ultima.
\end_layout

\begin_layout Standard
Un altro aspetto fondamentale riguarda la scelta del 
\emph on
motore grafico
\emph default
.
 Fin dalla versione originale era chiaro che sviluppare senza usare motori
 grafici di terze parti avrebbe aumentato esponenzialmente il tempi di sviluppo,
 rendendo di fatto impossibile supportare tutte le piattaforme desiderate.
 Sebbene oggi vi sia un gran numero di motori grafici gratuiti in grado
 di soddisfare la maggior parte delle esigenze, durante lo sviluppo della
 prima versione di OrbTail le scelte erano ben piú limitate.
 Le due tecnologie principali erano rappresentate da Unity 4.3 e UDK e, sebbene
 quest'ultimo garantiva un'ottima resa visiva, lo strumento risultava instabile,
 poco documentato e particolarmente macchinoso.
 Unity, d'altro canto, é sembrato fin da subito adatto agli scopi del progetto,
 specie per quanto riguarda il supporto dei dispositivi 
\emph on
mobile
\emph default
, ed in generale molto intuitivo.
 Considerando che per questo lavoro di tesi ci si aspettava la riscrittura
 della maggior parte del codice, é stata inoltre avanzata l'ipotesi di un
 cambio motore grafico a favore di Unreal Engine 4.
 Sebbene quest'ultimo avrebbe garantito un'eccellente resa grafica, l'idea
 é stata rapidamente accantonata per via delle iterazioni di sviluppo incredibil
mente piú lente che caratterizzano questo motore grafico, la mancanza di
 servizi di 
\emph on
matchmaking 
\emph default
e, soprattutto, delle criticitá riguardanti lo sviluppo su piattaforme 
\emph on
mobile
\emph default
 (specie in termini di performance ed ottimizzazione).
 Per questa nuova versione del titolo é stato pertanto deciso di aggiornare
 il motore grafico, passando da Unity 4.13 alla versione 2017.3, cercando
 di partire da una base quanto piú stabile possibile e proseguendo per iterazion
i successive.
\end_layout

\begin_layout Section
Unity
\end_layout

\begin_layout Standard
Unity é un motore grafico sviluppato da 
\emph on
Unity Technologies
\emph default
 che consente di sviluppare giochi multipiattaforma su tutte le pattaforme
 
\emph on
mobile
\emph default
, 
\emph on
console 
\emph default
e 
\emph on
desktop
\emph default
.
 La presenza di una versione gratuita unita ad un elevato grado di intuitivitá
 ne ha garantito la rapida affermazione da parte di sviluppatori 
\emph on
indipendenti
\emph default
 e non.
 Questo motore é caratterizzato da paradigmi di sviluppo molto chiari, il
 che lo rende tanto adatto agli sviluppatori alla prime armi quanto ai piú
 esperti.
 Il 
\emph on
pattern architetturale
\emph default
 principale, rappresentato dal
\emph on
l'entity-component
\emph default
, consiste nell'implementare funzionalitá autoconclusive all'interno di
 
\emph on
componenti 
\emph default
indipendenti ed usare i 
\emph on
game object 
\emph default
(termine usato da Unity per descrivere le 
\emph on
entitá
\emph default
)
\emph on
 
\emph default
come aggregatori di quest'ultimi al fine di modellare comportamenti piú
 complessi.
 Questo paradigma é stato migliorato nella versione del motore del 2018,
 introducendo il concetto di 
\emph on
system
\emph default
.
 Secondo questa variante, i componenti espongono solo dei dati e le logiche
 sono implementate all'interno dei sistemi, garantendo un disaccoppiamento
 ancora piú forte tra le varie componenti del gioco.
 Unity consente di implementare le logiche di gioco tramite script 
\emph on
C# 
\emph default
o 
\emph on
Javascript 
\emph default
e 
\emph on
shader 
\emph default
personalizzati tramite il linguaggio CG.
 L'assenza completa di codice nativo, ad eccezione del 
\emph on
core
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Il 
\emph on
core 
\emph default
di un motore grafico é il modulo software di piú basso livello.
 Esso si occupa di astrarre le funzionalitá specifiche di ciascuna piattaforma
 e di dettare il flusso di esecuzione di tutti gli altri sottosistemi, quali
 il renderer, il motore fisico, la logica di gioco e la gestione della memoria.
\end_layout

\end_inset


\emph default
, rende le iterazioni di sviluppo incredibilmente veloci in quanto non esiste
 un processo apposito di compilazione.
\end_layout

\begin_layout Standard
La limitazione maggiore di questo engine risiede nel fatto che il suo 
\emph on
core 
\emph default
é completamente 
\emph on
closed-source 
\emph default
(a meno di non pagare per ottenerne l'accesso) e ció impedisce agli sviluppatori
 di poterne analizzare il flusso di esecuzione, rendendo particolarmente
 difficile il processo di 
\emph on
debugging.
 
\emph default
Questa limitazione é stata mitigata durante il primo trimestre del 2018,
 quando Unity Technologies ne ha reso pubblico il codice sorgente C# su
 
\emph on
bitbucket
\begin_inset CommandInset citation
LatexCommand cite
key "UnityCSharp"

\end_inset

.
 
\emph default
Nonostante il rilascio del codice sia un notevole passo avanti, permane
 ancora l'impossibilitá di modificare il codice del motore per adattarlo
 meglio alle proprie esigenze e ció richiede talvolta l'impiego di soluzioni
 temporanee o alternative.
\end_layout

\begin_layout Standard
Per lo sviluppo di OrbTail sono state usate prevalentemente funzionalitá
 di base legate al 3D, al motore fisico, alla gestione delle scene e delle
 funzionalitá di rete.
 L'uso di funzionalitá generiche ha permesso di evitare tutte le problematiche
 legate ai sistemi piú specifici, quali gestione del 2D e delle 
\emph on
nav mesh 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Le 
\emph on
nav-mesh 
\emph default
(in italiano 
\begin_inset Quotes fld
\end_inset

mesh di navigazione
\begin_inset Quotes frd
\end_inset

) sono delle superfici poligonali solitamente usate dal sistema di 
\emph on
intelligenza artificiale 
\emph default
per determinare il percorso ottimo (o subottimo) tra due punti nello spazio.
\end_layout

\end_inset

, 
\emph default
le quali si sono talvolta dimostrate inaffidabili, limitate o afflitte da
 bug nascosti.
 L'intero codice sorgente del gioco é stato sviluppato in C#, utilizzando
 il paradigma 
\emph on
entity-component
\emph default
.
 L'integrazione del pattern 
\emph on
entity-component-system 
\emph default
é stata evitata in quanto questi risultava ancora in fase sperimentale e
 per via del fatto che lo sviluppo del gioco era giá in fase avanzata e
 si voleva evitare di correre 
\emph on
rischi
\emph default
 inutili.
 L'architettura di gioco sfrutta inoltre molti oggetti 
\emph on
manager
\emph default
 al fine di scambiare informazioni tra piú livelli e per fornire un unico
 punto d'accesso ai vari sottosistemi.
 Un manager é un'
\emph on
entitá
\emph default
 di gioco che funge da 
\emph on
singleton
\emph default
 accessibile da tutti gli altri sottosistemi al fine di leggerne o modificarne
 lo stato.
 
\end_layout

\begin_layout Standard
L'uso dell'apposito strumento di aggiornamento di versione fornito dal motore
 si é rivelato di notevole importanza, in quanto ha permesso fin da subito
 di ottenere un prodotto stabile a partire dalla versione originale del
 2013.
 Al termine del processo di 
\emph on
porting 
\emph default
automatico, il gioco ha preservato 
\emph on
tutte 
\emph default
le funzionalitá, comprese quelle legate alla rete, al 
\emph on
matchmaking
\emph default
 e al 
\emph on
cross-platform play 
\emph default
manifestando problematiche minori dovuto all'uso di 
\emph on
API 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Col termine
\emph on
 API, 
\emph default
acronimo di 
\emph on
application programming interface, 
\emph default
ci si riferisce a tutte quelle funzionalitá di un sistema rese disponibili
 agli sviluppatori tramite opportune 
\emph on
procedure
\emph default
.
\end_layout

\end_inset

 
\emph default
obsolete (principalmente in ambito 
\emph on
UI 
\emph default
e di gestione dei livelli).
 Una volta ottenuta una versione stabile, sono state infine aggiornate tutte
 le funzionalitá superate sostituendole con le nuove varianti messe a disposizio
ne del motore.
 Al termine di questa fase ci si é concentrati sull'aggiornamento dell'architett
ura del gioco e sull'implementazione delle nuove funzionalitá.
\end_layout

\begin_layout Subsection
Plug-in
\end_layout

\begin_layout Standard
Unity mette a disposizione un gran quantitativo di 
\emph on
plug-in 
\emph default
esterni al fine di aumentare la resa dei giochi, semplificare il processo
 di sviluppo o aggiungere nuove funzionalitá.
 Per lo sviluppo di OrbTail é stato deciso di utilizzarne uno solo
\emph on
 
\emph default
dal nome 
\emph on
iTween
\begin_inset CommandInset citation
LatexCommand cite
key "iTween"

\end_inset

.
 
\emph default
Questo plug-in gratuito é usato per gestire in maniera semplice ed automatica
 il processo di 
\emph on
tweening
\emph default
, ovvero l'interpolazione automatica di valori in un certo periodo di tempo
 attraverso il sistema di 
\emph on
coroutine 
\emph default
di C#.
 Il plug-in é stato utilizzato principalmente per aggiungere animazioni
 agli elementi dell'interfaccia grafica ed in misura molto minore per gli
 elementi di gioco 3D.
 L'uso di questo sistema ha permesso di risparmiare un notevole quantitativo
 di tempo, garantendo una resa visiva molto buona.
 Quest'ultimo si presenta come un unico file monolitico che puó essere integrato
 nel progetto e non richiede alcuna forma di configurazione.
 Nella fase di 
\emph on
porting 
\emph default
é stato necessario aggiornare il plug-in alla versione piú recente.
\end_layout

\begin_layout Section
Meccaniche di base
\end_layout

\begin_layout Standard
La prima fase implementativa di OrbTail si é concentrata sulla definizione
 dell'architettura generale del gioco ed in particolar modo sulle meccaniche
 di base del gioco.
 Queste meccaniche sono condivise tra tutte le modalitá di gioco e su tutti
 i livelli, quindi sono state progettate per essere indipendenti da quest'ultime.
 All'interno delle meccaniche di base troviamo la gestione del sistema di
 controllo del movimento, degli scontri, dei potenziamenti, degli oggetti
 collezionabili e la gestione della gravitá.
 Queste meccaniche sono state inizialmente sviluppate per la modalitá a
 giocatore singolo e poi aggiornate per supportare il sistema di networking.
\end_layout

\begin_layout Subsection
Sistema di controllo
\end_layout

\begin_layout Standard
La prima meccanica fondamentale riguarda il sistema di controllo del veicolo.
\end_layout

\begin_layout Subsection
Gestione della gravitá
\end_layout

\begin_layout Standard
I livelli offerti dal gioco sono caratterizzati da una diversa topologia
 che rende impossibile usare la gravitá automatica del motore grafico.
 Durante le fasi prototipali ci si affidava al raycast in modo da individuare
 un punto sulla superficie da usare come ancora per gli oggetti all'interno
 dell'arena, tuttavia questo approccio manifestava un gran numero di bug,
 dovuti principalmente al fatto che non era chiaro, data la posizione e
 l'orientamento del veicolo, stabilire in quale direzione doveva essere
 effettuato il raycast, rendendo ambiguo il risultato in caso di rollio
 del veicolo o, peggio ancora, a seguito di esplosioni che possono cambiare
 molto rapidamente la direzione del veicolo.
\end_layout

\begin_layout Standard
Il secondo approccio tentato invece consiste nel fornire una descrizione
 analitica del campo gravitazionale per ciascuna topologia supportata.
 Questo approccio si é rivelato fin da subito vincente: per le forme piú
 semplici una semplice descrizione della funzione di gravitá é sufficiente
 per risolvere qualsiasi tipo di ambiguitá, indipendentemente dall'orientamento
 dell'oggetto.
 La gestione della gravitá é affidata a due componenti speciali: una classe
 base GravityField, da cui derivano ConstantGravityField, RadialGravityField
 e ToroidalGravityField associati all'arena ed un FloatingObject che, assegnato
 agli oggetti di gioco permette loro di fluttuare sull'arena (Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OrbTailGravity"

\end_inset

).
 
\begin_inset Float figure
placement !h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename C:/Users/raffa/Documents/Repo/OrbTail/Doc/Tesi/img/dev_gravity.jpg
	lyxscale 20
	height 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Gestione della gravitá.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:OrbTailGravity"

\end_inset

UML Gestione della gravitá.
\end_layout

\end_inset


\end_layout

\end_inset

 Tramite questo componenti é possibile definire intensitá e direzione della
 forza di gravitá, la distanza a cui gli oggetti fluttuano rispetto alla
 superficie e vari parametri di molleggiamento.
 Il raycast rimane comunque necessario per impedire che gli oggetti possano
 compenetrare con l'arena e per individuare il punto di hover(?).
 Sul punto di hovering la gravitá si comporta come una molla e ció garantisce
 un buon effetto di rimbalzo (?).
\end_layout

\begin_layout Section
Networking
\end_layout

\begin_layout Section
Arene
\end_layout

\begin_layout Section
Modalitá di gioco
\end_layout

\begin_layout Section
Intelligenza artificiale
\end_layout

\begin_layout Section
Potenziamenti
\end_layout

\begin_layout Section
Splitscreen
\end_layout

\begin_layout Section
Gestione degli input
\end_layout

\begin_layout Section
Menú
\end_layout

\end_body
\end_document
