#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../tesi.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Per la realizzazione di OrbTail ci si è serviti di un metodo di sviluppo
 a fasi.
 La fase preliminare si è concentrata sulla definizione delle tecnologie
 impiegate: l'attenta scelta di quest'ultime è di cruciale importanza per
 minimizzare l'impatto sul processo produttivo in caso di criticitá o limitazion
i, specie nelle fasi piú avanzate del progetto.
 Per permettere a piú sviluppatori di lavorare sul progetto in contemporanea,
 mantenere lo storico dei file di progetto e controllare lo sviluppo delle
 varie funzionalitá ci si è affidati a 
\emph on
git
\emph default
, un software per il 
\emph on
controllo di versione 
\emph default
distribuito.
 Per via degli interventi molto estesi che hanno visto la riscrittura quasi
 completa dei contributi originali, la 
\emph on
repository 
\emph default
del gioco risalente al 2013 è stata duplicata e il processo di sviluppo
 descritto in questo lavoro di tesi è proseguito su quest'ultima.
\end_layout

\begin_layout Standard
Un altro aspetto fondamentale riguarda la scelta del 
\emph on
motore grafico
\emph default
.
 Fin dalla versione originale era chiaro che sviluppare senza usare motori
 grafici di terze parti avrebbe aumentato esponenzialmente il tempi di sviluppo,
 rendendo di fatto impossibile supportare tutte le piattaforme desiderate.
 Sebbene oggi vi sia un gran numero di motori grafici gratuiti in grado
 di soddisfare la maggior parte delle esigenze, durante lo sviluppo della
 prima versione di OrbTail le scelte erano ben piú limitate.
 Le due tecnologie principali erano rappresentate da Unity 4.3 e UDK e, sebbene
 quest'ultimo garantiva un'ottima resa visiva, lo strumento risultava instabile,
 poco documentato e particolarmente macchinoso.
 Unity, d'altro canto, è sembrato fin da subito adatto agli scopi del progetto,
 specie per quanto riguarda il supporto dei dispositivi 
\emph on
mobile
\emph default
, ed in generale molto intuitivo.
 Considerando che per questo lavoro di tesi ci si aspettava la riscrittura
 della maggior parte del codice, è stata inoltre avanzata l'ipotesi di un
 cambio motore grafico a favore di Unreal Engine 4.
 Sebbene quest'ultimo avrebbe garantito un'eccellente resa grafica, l'idea
 è stata rapidamente accantonata per via delle iterazioni di sviluppo incredibil
mente piú lente che caratterizzano questo motore grafico, la mancanza di
 servizi di 
\emph on
matchmaking 
\emph default
e, soprattutto, delle criticitá riguardanti lo sviluppo su piattaforme 
\emph on
mobile
\emph default
 (specie in termini di prestazioni ed ottimizzazioni).
 Per questa nuova versione del titolo è stato pertanto deciso di aggiornare
 il motore grafico, passando da Unity 4.13 alla versione 2017.3, cercando
 di partire da una base quanto piú stabile possibile e proseguendo per iterazion
i successive.
\end_layout

\begin_layout Section
Unity
\end_layout

\begin_layout Standard
Unity è un motore grafico sviluppato da 
\emph on
Unity Technologies
\emph default
 che consente di sviluppare giochi multipiattaforma su tutte le pattaforme
 
\emph on
mobile
\emph default
, 
\emph on
console 
\emph default
e 
\emph on
desktop
\emph default
.
 La presenza di una versione gratuita unita ad un elevato grado di intuitivitá
 ne ha garantito la rapida affermazione da parte di sviluppatori 
\emph on
indipendenti
\emph default
 e non.
 Questo motore è caratterizzato da paradigmi di sviluppo molto chiari, il
 che lo rende tanto adatto agli sviluppatori alla prime armi quanto ai piú
 esperti.
 Il 
\emph on
pattern architetturale
\emph default
 principale, rappresentato dal
\emph on
l'entity-component
\emph default
, consiste nell'implementare funzionalitá autoconclusive all'interno di
 
\emph on
componenti 
\emph default
indipendenti ed usare i 
\emph on
game object 
\emph default
(termine usato da Unity per descrivere le 
\emph on
entitá
\emph default
)
\emph on
 
\emph default
come aggregatori di quest'ultimi al fine di modellare comportamenti piú
 complessi.
 Questo paradigma è stato migliorato nella versione del motore del 2018,
 introducendo il concetto di 
\emph on
system
\emph default
.
 Secondo questa variante, i componenti espongono solo dei dati e le logiche
 sono implementate all'interno dei sistemi, garantendo un disaccoppiamento
 ancora piú forte tra le varie componenti del gioco.
 Unity consente di implementare le logiche di gioco tramite script 
\emph on
C# 
\emph default
o 
\emph on
Javascript 
\emph default
e 
\emph on
shader 
\emph default
personalizzati tramite il linguaggio CG.
 L'assenza completa di codice nativo, ad eccezione del 
\emph on
core
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Il 
\emph on
core 
\emph default
di un motore grafico è il modulo software di piú basso livello.
 Esso si occupa di astrarre le funzionalitá specifiche di ciascuna piattaforma
 e di dettare il flusso di esecuzione di tutti gli altri sottosistemi, quali
 il renderer, il motore fisico, la logica di gioco e la gestione della memoria.
\end_layout

\end_inset


\emph default
, rende le iterazioni di sviluppo incredibilmente veloci in quanto non esiste
 un processo apposito di compilazione.
\end_layout

\begin_layout Standard
La limitazione maggiore di questo engine risiede nel fatto che il suo 
\emph on
core 
\emph default
è completamente 
\emph on
closed-source 
\emph default
(a meno di non pagare per ottenerne l'accesso) e ció impedisce agli sviluppatori
 di poterne analizzare il flusso di esecuzione, rendendo particolarmente
 difficile il processo di 
\emph on
debugging.
 
\emph default
Questa limitazione è stata mitigata durante il primo trimestre del 2018,
 quando Unity Technologies ne ha reso pubblico il codice sorgente C# su
 
\emph on
bitbucket
\begin_inset CommandInset citation
LatexCommand cite
key "UnityCSharp"

\end_inset

.
 
\emph default
Nonostante il rilascio del codice sia un notevole passo avanti, permane
 ancora l'impossibilitá di modificare il codice del motore per adattarlo
 meglio alle proprie esigenze e ció richiede talvolta l'impiego di soluzioni
 temporanee o alternative.
\end_layout

\begin_layout Standard
Per lo sviluppo di OrbTail sono state usate prevalentemente funzionalitá
 di base legate al 3D, al motore fisico, alla gestione delle scene e delle
 funzionalitá di rete.
 L'uso di funzionalitá generiche ha permesso di evitare tutte le problematiche
 legate ai sistemi piú specifici, quali gestione del 2D e delle 
\emph on
nav mesh 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Le 
\emph on
nav-mesh 
\emph default
(in italiano 
\begin_inset Quotes fld
\end_inset

mesh di navigazione
\begin_inset Quotes frd
\end_inset

) sono delle superfici poligonali solitamente usate dal sistema di 
\emph on
intelligenza artificiale 
\emph default
per determinare il percorso ottimo (o subottimo) tra due punti nello spazio.
\end_layout

\end_inset

, 
\emph default
le quali si sono talvolta dimostrate inaffidabili, limitate o afflitte da
 bug nascosti.
 L'intero codice sorgente del gioco è stato sviluppato in C#, utilizzando
 il paradigma 
\emph on
entity-component
\emph default
.
 L'integrazione del pattern 
\emph on
entity-component-system 
\emph default
è stata evitata in quanto questi risultava ancora in fase sperimentale e
 per via del fatto che lo sviluppo del gioco era giá in fase avanzata e
 si voleva evitare di correre 
\emph on
rischi
\emph default
 inutili.
 L'architettura di gioco sfrutta inoltre molti oggetti 
\emph on
manager
\emph default
 al fine di scambiare informazioni tra piú livelli e per fornire un unico
 punto d'accesso ai vari sottosistemi.
 Un manager è un'
\emph on
entitá
\emph default
 di gioco che funge da 
\emph on
singleton
\emph default
 accessibile da tutti gli altri sottosistemi al fine di leggerne o modificarne
 lo stato.
 
\end_layout

\begin_layout Standard
L'uso dell'apposito strumento di aggiornamento di versione fornito dal motore
 si è rivelato di notevole importanza, in quanto ha permesso fin da subito
 di ottenere un prodotto stabile a partire dalla versione originale del
 2013.
 Al termine del processo di 
\emph on
porting 
\emph default
automatico, il gioco ha preservato 
\emph on
tutte 
\emph default
le funzionalitá, comprese quelle legate alla rete, al 
\emph on
matchmaking
\emph default
 e al 
\emph on
cross-platform play 
\emph default
manifestando problematiche minori dovuto all'uso di 
\emph on
API 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Col termine
\emph on
 API, 
\emph default
acronimo di 
\emph on
application programming interface, 
\emph default
ci si riferisce a tutte quelle funzionalitá di un sistema rese disponibili
 agli sviluppatori tramite opportune 
\emph on
procedure
\emph default
.
\end_layout

\end_inset

 
\emph default
obsolete (principalmente in ambito 
\emph on
UI 
\emph default
e di gestione dei livelli).
 Una volta ottenuta una versione stabile, sono state infine aggiornate tutte
 le funzionalitá superate sostituendole con le nuove varianti messe a disposizio
ne del motore.
 Al termine di questa fase ci si è concentrati sull'aggiornamento dell'architett
ura del gioco e sull'implementazione delle nuove funzionalitá.
\end_layout

\begin_layout Subsection
Plug-in
\end_layout

\begin_layout Standard
Unity mette a disposizione un gran quantitativo di 
\emph on
plug-in 
\emph default
esterni al fine di aumentare la resa dei giochi, semplificare il processo
 di sviluppo o aggiungere nuove funzionalitá.
 Per lo sviluppo di OrbTail è stato deciso di utilizzarne uno solo
\emph on
 
\emph default
dal nome 
\emph on
iTween
\begin_inset CommandInset citation
LatexCommand cite
key "iTween"

\end_inset

.
 
\emph default
Questo plug-in gratuito è usato per gestire in maniera semplice ed automatica
 il processo di 
\emph on
tweening
\emph default
, ovvero l'interpolazione automatica di valori in un certo periodo di tempo
 attraverso il sistema di 
\emph on
coroutine 
\emph default
di C#.
 Il plug-in è stato utilizzato principalmente per aggiungere animazioni
 agli elementi dell'interfaccia grafica ed in misura molto minore per gli
 elementi di gioco 3D.
 L'uso di questo sistema ha permesso di risparmiare un notevole quantitativo
 di tempo, garantendo una resa visiva molto buona.
 Quest'ultimo si presenta come un unico file monolitico che puó essere integrato
 nel progetto e non richiede alcuna forma di configurazione.
 Nella fase di 
\emph on
porting 
\emph default
è stato necessario aggiornare il plug-in alla versione piú recente.
\end_layout

\begin_layout Section
Meccaniche di base
\end_layout

\begin_layout Standard
La prima fase dello sviluppo di OrbTail si concentra sulla definizione dell'arch
itettura generale del gioco ed in particolar modo delle meccaniche di base.
 Quest'ultime sono condivise tra tutte le modalitá e livelli e pertanto
 sono state pensate per essere completamente indipendenti da essi.
 Tra le meccaniche di base troviamo la gestione della gravitá, del sistema
 di controllo dei veicoli, della gestione degli oggetti collezionabili e
 degli impatti 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:VehicleComponents"

\end_inset

)
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/raffa/Documents/Repo/OrbTail/Doc/Tesi/img/ship.jpg
	lyxscale 20
	width 14cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Componenti dei veicoli
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:VehicleComponents"

\end_inset

Componenti dei veicoli
\end_layout

\end_inset


\end_layout

\end_inset

..
 Tutte le funzionalitá qui descritte sono state sviluppate in una mappa
 di test apposita, con risorse grafiche temporanee e gestione degli input
 molto basilare.
\end_layout

\begin_layout Subsection
Gestione della gravitá
\end_layout

\begin_layout Standard
I livelli offerti dal gioco sono caratterizzati da topologie profondamente
 diverse, il che rende impossibile utilizzare la gravitá automatica fornita
 dal motore fisico di Unity per far fluttuare gli oggetti su di essi.
 Durante la prima iterazione ci si è affidati al sistema di 
\emph on
raycasting 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Il 
\emph on
raycasting 
\emph default
è una tecnica che consente di determinare le intersezioni tra un raggio
 descritto da un punto inziale ed una direzione ed una o piú superfici poligonal
i.
\end_layout

\end_inset

 
\emph default
al fine di individuare un punto sulla superficie del livello da usare come
 base per il calcolo, tuttavia ci si è presto accorti che il sistema era
 affetto da gravi difetti.
 Sebbene l'uso del 
\emph on
raycast 
\emph default
permette di scrivere un codice di gestione unico che si adatta a tutte le
 topologie, determinare la direzione del raggio usando solo l'orientamento
 dell'oggetto puó generare risultati ambigui o imprevedibili.
 Queste problematiche sono esacerbate da rapidi cambi di direzione a seguito
 di esplosioni o durante il normale 
\emph on
rollio 
\emph default
degli oggetti lungo la superficie del livello.
 Per risolvere questa ambiguitá ci si è affidati ad una descrizione 
\emph on
analitica 
\emph default
della forza di gravitá per ciascuna delle topologie supportate.
 Il 
\emph on
campo gravitazionale
\emph default
 cosí descritto consente di ottenere una direzione non ambigua in cui effettuare
 il 
\emph on
raycasting
\emph default
 per ogni punto dello spazio.
 Una volta individuato il punto sulla superficie, una semplice simulazione
 di un 
\emph on
moto oscillatorio smorzato 
\emph default
permette di modellare lo stazionamento degli oggetti sull'arena.
\end_layout

\begin_layout Standard
La soluzione adottata prevede l'uso di due elementi principali: un componente
 base 
\emph on
GravityField, 
\emph default
da cui derivano le diverse descrizioni dei campi di gravitá supportati,
\emph on
 
\emph default
e il 
\emph on
FloatingObject 
\emph default
che, assegnato agli oggetti di gioco, consente loro di fluttuare sull'arena
 (Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:OrbTailGravity"

\end_inset

).
\begin_inset Float figure
placement !h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename C:/Users/raffa/Documents/Repo/OrbTail/Doc/Tesi/img/dev_gravity.jpg
	lyxscale 20
	height 7cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Gestione della gravitá.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:OrbTailGravity"

\end_inset

Gestione della gravitá.
\end_layout

\end_inset


\end_layout

\end_inset

 Il primo di questi viene assegnato all'arena e consente di configurare
 sia l'intensitá della gravitá e sia la distanza di stazionamento degli
 oggetti rispetto alla superficie per impedire che questi possano compenetravi.
 Il secondo si occupa di simulare lo stazionamento dell'oggetto a partire
 dalla direzione della forza di gravitá.
\end_layout

\begin_layout Subsection
Sistema di controllo
\end_layout

\begin_layout Standard
Il sistema di controllo di ciascun veicolo si occupa di gestire il movimento
 di quest'ultimo all'interno dell'arena considerando la direzione della
 forza di gravitá e l'input dell'utente.
\end_layout

\begin_layout Standard
Il componente 
\emph on
MovementController
\emph default
 determina la velocitá lineare e quella angolare del veicolo in ogni istante
 e applica opportune forze al 
\emph on
corpo rigido 
\emph default
di quest'ultimo per causarne il movimento fisico.
 La gestione del movimento non è simulata in maniera fisicamente accurata,
 bensí è affidata ad un semplice controllore 
\emph on
PID.
 
\emph default
Il sistema adoperato consente di controllare la velocitá da applicare 
\begin_inset Formula $u(t)$
\end_inset

 in funzione di quella attuale del veicolo 
\begin_inset Formula $y(t)$
\end_inset

 e di quella desiderata 
\begin_inset Formula $r(t)$
\end_inset

 usando la sola azione di controllo 
\emph on
proporzionale 
\emph default
con costante 
\begin_inset Formula $K_{p}$
\end_inset

.
 Un controllore analogo è utilizzato per gestire l'azione di sterzo e la
 velocitá angolare risultate.
 Per questa particolare implementazione le azioni 
\emph on
integrali 
\emph default
e 
\emph on
derivative 
\emph default
non sono state ritenute necessarie:
\begin_inset Formula 
\[
u(t)=K_{p}(r(t)-y(t))
\]

\end_inset


\end_layout

\begin_layout Standard
La velocitá desiderata 
\begin_inset Formula $r(t)$
\end_inset

 è determinata dal valore massimo di 
\emph on
velocitá 
\emph default
del veicolo 
\begin_inset Formula $r_{max}>0$
\end_inset

 e dall'input dell'utente 
\begin_inset Formula $r_{in}\in[-1;+1]$
\end_inset

.
 Il termine proporzionale 
\begin_inset Formula $K_{e}$
\end_inset

 è invece proporzionale al suo parametro di 
\emph on
accelerazione
\emph default
.
 L'azione di sterzo segue un principio identico ma ha costanti che dipendono
 dalla 
\emph on
manovrabilitá 
\emph default
del veicolo (vedi 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Veicoli"

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
r(t)=r_{max}\cdot r_{in}
\]

\end_inset


\end_layout

\begin_layout Standard
La direzione di accelerazione è ricavata tramite il componente 
\emph on
FloatingObject
\emph default
 in funzione della tangente del campo di gravitá e della rotazione del veicolo,
 e ció impedisce che quest'ultimo possa percorrere la superficie del livello
 passandovici attraverso.
\end_layout

\begin_layout Subsection
Gestione dei collezionabili
\end_layout

\begin_layout Standard
La gestione della collezione degli elementi di gioco è affidata a tre componenti
 fondamentali.
 Il primo di questi, il 
\emph on
ProximityHandler
\emph default
, rappresenta un 
\emph on
volume di collisione sferico 
\emph default
attorno al veicolo il quale lancia un'opportuno evento quando un 
\emph on
orb 
\emph default
vi compenetra.
 Questo componente fa parte del 
\emph on
game object 
\emph default
che rappresenta il veicolo, assieme ad un ulteriore componente 
\emph on
Ship 
\emph default
che si preoccupa di gestire le logiche di base della coda, quali aggiungere
 o rimuoverne elementi.
 Il collegamento tra diversi 
\emph on
orb
\emph default
 è gestito attraverso un 
\emph on
vincolo fisico 
\emph default
di tipo molla, con una lunghezza massima tale per cui questi possano muoversi
 liberamente senza peró allontanarsi da quello che li precede nella coda.
 Una volta rimossi dalla coda, il vincolo fisico viene rimosso e l'
\emph on
orb 
\emph default
viene proiettato in una direzione casuale al fine di allontanarlo dal veicolo.
 Il 
\emph on
game object 
\emph default
che rappresenta ciascun 
\emph on
orb 
\emph default
usa il componente 
\emph on
FloatingObject 
\emph default
al fine di fluttuare sull'arena e un altro componente, l'
\emph on
OrbController
\emph default
, al fine di gestire i vincoli fisici di cui sopra.
\end_layout

\begin_layout Subsection
Gestione degli impatti
\end_layout

\begin_layout Standard
Il sistema di gestione degli scontri tra veicoli è implementato attraverso
 un componente 
\emph on
FightController, 
\emph default
il cui scopo è quello di rilevare gli impatti e notificare il componente
 
\emph on
Ship 
\emph default
del numero di 
\emph on
orb 
\emph default
persi come conseguenza.
 Le collisioni tra veicoli sono gestite direttamente dal motore fisico di
 Unity.
 Nella versione originale ciascuno di essi aveva uno o piú 
\emph on
collisori fisici 
\emph default
che approssimavano piú o meno precisamente la loro topologia, tuttavia questo
 approccio causava comportamenti inaspettati durante la risoluzione delle
 collisioni quali veicoli che si incastravano tra loro oppure la generazione
 di impulsi fisici di entitá molto elevata che causavano la perdita di tutti
 gli 
\emph on
orb
\emph default
 disponibili.
 Al fine di non avvantaggiare nessun veicolo ed evitare queste problematiche,
 nell'ultima versione ci si è affidati all'uso di un 
\emph on
collisore sferico 
\emph default
unico che approssima la superficie del veicolo racchiudendone il modello
 grafico.
 La forma e la dimensione del collisore è identica per tutti i veicoli e
 ció garantisce un'elevata consistenza durante la risoluzione degli scontri.
 Una volta rilevata una collisione durante quest'ultimi, il motore fisico
 genera una coppia di eventi, uno per ogni componente coinvolto nell'impatto.
 Ciascun 
\emph on
FightController 
\emph default
reagisce a questi eventi, determinando il numero di 
\emph on
orb 
\emph default
persi a causa dello scontro e lasciando al 
\emph on
FightController 
\emph default
del veicolo avversario il compito di staccare 
\emph on
orb 
\emph default
dal proprio.
\end_layout

\begin_layout Standard
Il numero di 
\emph on
orb 
\emph default
persi durante uno scontro dipende dalla direzione d'impatto e l'orientamento
 dei veicoli coinvolti: uno scontro frontale deve causare un distacco di
 
\emph on
orb 
\emph default
da parte di entrambi i veicoli, laddove colpire un veicolo su una fiancata
 non deve penalizzare in alcun modo l'aggressore.
\end_layout

\begin_layout Standard
Sia 
\begin_inset Formula $p$
\end_inset

 la posizione del veicolo sui cui viene generato l'evento di collisione,
 
\begin_inset Formula $f$
\end_inset

 la direzione di quest'ultimo, 
\begin_inset Formula $c$
\end_inset

 il punto di impatto trai veicoli convolti e 
\begin_inset Formula $v_{rel}$
\end_inset

 la velocitá relativa del veicolo rispetto all'avversario, la formula usata
 per determinare il numero di 
\emph on
danni 
\emph default
inflitti 
\begin_inset Formula $d$
\end_inset

 è la seguente:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
i_{d}=\frac{c-p}{|c-p|}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
i_{s}=\max(0,i_{d}\cdot f)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d=|v_{rel}|\cdot i_{s}\cdot off
\]

\end_inset


\end_layout

\begin_layout Standard
Il termine 
\begin_inset Formula $i_{d}$
\end_inset

 rappresenta la 
\emph on
direzione relativa di impatto
\emph default
, 
\begin_inset Formula $i_{s}$
\end_inset

 è invece un fattore di scala che impedisce ai veicoli di causare danni
 al di fuori di un cono frontale.
 Il numero di 
\emph on
orb
\emph default
 
\begin_inset Formula $o_{imp}$
\end_inset

 persi dal veicolo a seguito dell'impatto è calcolato come segue:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
o_{imp}=\lfloor d\cdot def^{-1}\rfloor
\]

\end_inset


\end_layout

\begin_layout Standard
I termini 
\begin_inset Formula $off$
\end_inset

 e 
\begin_inset Formula $def$
\end_inset

 sono due parametri che identificano il potere offensivo e quello difensivo
 di ciascun veicolo.
 Un tempo differenziati per veicolo, questi parametri sono oggi usati per
 rimappare il valore del danno causato e ricavare il numero di 
\emph on
orb 
\emph default
perduti e sono uguali per tutti.
\end_layout

\begin_layout Section
Architettura di rete
\end_layout

\begin_layout Standard
Nella versione originale di OrbTail l'architettura di gioco si basava su
 classi apposite che discriminavano le modalitá multigiocatore online delle
 modalitá a giocatore singolo, gestendo di volta in volta i casi speciali.
 In questa nuova iterazione il sistema è stato semplificato e generalizzato,
 al fine di gestire in maniera uniforme tutte le modalitá e configurazioni
 supportate.

\emph on
 
\emph default
L'architettura di rete di OrbTail è di tipo 
\emph on
client-server
\emph default
 e uno dei dispositivi dei giocatori è usato come 
\emph on
host 
\emph default
per la partita.
 Dato il basso numero di giocatori coinvolti, questa soluzione è ottimale
 perchè garantisce un buona esperienza 
\emph on
online 
\emph default
evitando i costi associati ad un server dedicato.
 Il 
\emph on
server 
\emph default
si occupa di gestire tutti gli elementi di gioco quali 
\emph on
orb 
\emph default
e 
\emph on
core
\emph default
 e i veicoli gestiti dalla 
\emph on
IA, 
\emph default
laddove ogni 
\emph on
client 
\emph default
gestirá uno o piú veicoli associati ai giocatori locali (in caso di 
\emph on
multigiocatore splitscreen).
 
\emph default
Sebbene il dispositivo 
\emph on
host 
\emph default
sia contemporaneamente 
\emph on
server 
\emph default
e 
\emph on
client
\emph default
, le due parti sono gestite in maniera indipendente.
 L'
\emph on
host 
\emph default
in funzione di 
\emph on
client 
\emph default
richiede in ogni caso una connessione al 
\emph on
server 
\emph default
al fine di inviare comandi e riceverne aggiornamenti
\emph on
: 
\emph default
il sistema di rete di Unity provvederá a simulare le richieste di rete sulla
 stessa applicazione in maniera trasparante.
\end_layout

\begin_layout Standard
La sincronizzazione degli stati di gioco avviene secondo due possibili meccanism
i forniti da Unity: la 
\emph on
replicazione
\emph default
 e le 
\emph on
chiamate remote
\emph default
 (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:NetArchitecture"

\end_inset

)
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/raffa/Documents/Repo/OrbTail/Doc/Tesi/img/dev_net.jpg
	lyxscale 20
	width 14cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Architettura di rete di OrbTail
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:NetArchitecture"

\end_inset

Architettura di rete di OrbTail
\end_layout

\end_inset


\end_layout

\end_inset

.
 Il primo di questi consente al server di propagare il valore di uno stato
 di gioco su tutti gli oggetti client costantemente.
 Questo metodo è particolarmente adatto per valori che cambiano molto rapidament
e di cui peró non è necessario che vi sia una forte corrispondenza tra la
 versione sul 
\emph on
server 
\emph default
e quella sul 
\emph on
client,
\emph default
 quali ad esempio la posizione dei veicoli ed il punteggio dei giocatori.
 Il 
\emph on
server
\emph default
 ha sempre 
\emph on
autoritá
\emph default
 sui valori sincronizzati in questo modo e pertanto non è possibile utilizzare
 questo meccanismo nel senso opposto al fine di inviare dati dal 
\emph on
client 
\emph default
al 
\emph on
server.
\end_layout

\begin_layout Standard
Il secondo meccanismo, noto col termine
\emph on
 
\emph default

\begin_inset Quotes fld
\end_inset

remote procedure call
\begin_inset Quotes frd
\end_inset

 (
\emph on
RPC
\emph default
)
\emph on
, 
\emph default
consente di chiamare un metodo di un oggetto su un'istanza remota di gioco.
 Unity ne fornisce due varianti, la prima è rappresentata dai 
\emph on
comandi
\emph default
 i quali sono usati per inviare un'azione dal 
\emph on
client
\emph default
 al 
\emph on
server
\emph default
, la seconda è rappresentata dalle 
\emph on
client RPC 
\emph default
le quali vengono inviate dal server e propagate su 
\emph on
tutti 
\emph default
i client.
 Questo metodo è adatto per eventi di sincronizzazione che avvengono di
 rado ma per i quali vi deve essere l'assoluta certezza che i 
\emph on
client 
\emph default
ne vengano notificati, come ad esempio gli eventi che determinano l'inizio
 o la fine di una partita.
\end_layout

\begin_layout Standard
Il paradigma fondamentale su cui si basa Unity consiste nell'inviare 
\emph on
comandi 
\emph default
dal client al server, attendere che questo ne verifichi la validitá aggiornando
 lo stato di gioco e quindi propagare quest'ultimo tramite 
\emph on
replicazione 
\emph default
oppure tramite 
\emph on
client RPC
\emph default
.
 Secondo questo paradigma, ignorando i tempi necessari per inviare i messaggi
 sulla rete, tutti i 
\emph on
client
\emph default
 osservano sempre lo stesso stato di gioco.
\end_layout

\begin_layout Standard
Ad ogni giocatore connesso ad una partita viene associato un particolare
 
\emph on
game object 
\emph default
che ne contiene i dati identificativi e ne rappresenta la volontá.
 Per ragioni di sicurezza è possibile inviare 
\emph on
comandi 
\emph default
al server solo attraverso di esso e solo se il giocatore locale ne ha l'
\emph on
autoritá
\emph default
, ovvero se il 
\emph on
game object 
\emph default
in questione rappresenta la sua identitá e non quella di un altro giocatore.
\end_layout

\begin_layout Subsection
Gestione della lobby
\end_layout

\begin_layout Standard
Una 
\emph on
lobby 
\emph default
è una 
\emph on
stanza virtuale 
\emph default
a cui altri utenti online possono connettersi.
 Quest'ultima contiene le informazioni di configurazione della partita prima
 del suo avvio quali la modalitá di gioco e l'arena selezionata.
 Le 
\emph on
lobby
\emph default
 sono gestite attraverso un 
\emph on
singleton 
\emph default
derivato dalla classe di Unity 
\emph on
NetworkLobbyManager
\emph default
, la quale astrae tutte le logiche di creazione o ricerca di una partita,
 connessione e disconnesione degli utenti e sincronizzazione della configurazion
e di gioco.
 Ogni giocatore connesso ad una 
\emph on
lobby 
\emph default
è associato ad un oggetto di tipo 
\emph on
LobbyPlayer
\emph default
, il quale viene usato sia per inviare comandi al 
\emph on
server 
\emph default
e sia per rappresentare i dati del giocatore, quali il suo indice nella
 partita, il veicolo scelto e le informazioni riguardanti la connessione.
\end_layout

\begin_layout Standard
Una volta che l'utente ha deciso la configurazione della partita, il 
\emph on
Lobby Manager
\emph default
 usa i servizi di 
\emph on
matchmaking 
\emph default
di Unity al fine di individuare 
\emph on
lobby 
\emph default
esistenti con configurazione compatibile.
 Questo servizio indicizza tutte le 
\emph on
lobby 
\emph default
pubbliche, esponendo varie informazioni quali i loro nomi, il numero massimo
 di giocatori, il numero di utenti attualmente connessi e tutte le informazioni
 necessarie per connettersi ad essa.
 Sebbene il sistema consente di associare a ciascuna 
\emph on
lobby 
\emph default
delle 
\emph on
metainformazioni 
\emph default
(come ad esempio la modalitá di gioco), un 
\emph on
bug 
\emph default
di Unity impedisce a quest'informazione di essere replicata correttamente,
 impedendone completamente il suo utilizzo.
 Per ovviare a questo inconveniente è stato deciso di usare il nome della
 
\emph on
lobby 
\emph default
per 
\emph on
codificare 
\emph default
le metainformazioni necessarie in formato CSV.
 La lista di 
\emph on
lobby 
\emph default
cosí ottenuta viene filtrata a seconda della configurazione dell'utente
 ed il sistema provvede a connettersi ad una qualsiasi tra quelle rimaste.
 Se il tentativo di connessione fallisce (come potrebbe capitare se, nel
 frattempo, la partita in quella lobby è giá iniziata) vengono effettuati
 tentativi di connessione addizionali sulle altre lobby fino ad un numero
 massimo configurabile.
 Se non è stato possibile individuare una 
\emph on
lobby 
\emph default
compatibile, il sistema provvede a crearne una nuova e a registrarla pubblicamen
te al servizio di 
\emph on
matchmaking 
\emph default
affinchè altri giocatori possano connettersi.
 Nel caso di partite a giocatore singolo le fasi di ricerca delle 
\emph on
lobby 
\emph default
e di registrazione al servizio di 
\emph on
matchmaking 
\emph default
vengono ignorate ma la 
\emph on
lobby 
\emph default
viene comunque creata.
 
\end_layout

\begin_layout Standard
Ogni volta che un giocatore entra in una 
\emph on
lobby
\emph default
, il 
\emph on
LobbyManager 
\emph default
crea un oggetto di tipo 
\emph on
LobbyPlayer 
\emph default
che lo rappresenta, replicando tutte le informazioni salienti agli altri
 giocatori in partita (quali l'indice del giocatore nella partita ed il
 veicolo scelto).
 Un utente puó abbandonare una 
\emph on
lobby 
\emph default
in qualsiasi momento.
\end_layout

\begin_layout Standard
Per procedere con l'avvio della partita, gli utenti connessi devono esplicitamen
te inviare un 
\emph on
comando 
\emph default
al server, dichiarando di essere 
\begin_inset Quotes fld
\end_inset

pronti
\begin_inset Quotes frd
\end_inset

.
 Quando l'ultimo di questi 
\emph on
comandi 
\emph default
viene ricevuto, il server 
\emph on
blocca 
\emph default
la partita pubblica (se presente) rimuovendola dal servizio di 
\emph on
matchmaking
\emph default
, impedendo ad altri giocatori di potersi connettere.
 A questo punto il 
\emph on
server 
\emph default
genera 
\emph on
LobbyPlayer 
\emph default
addizionali finchè il numero di partecipanti non diventa esattamente 
\emph on
quattro:
\emph default
 questi giocatori sono configurati per essere comandati dal sistema di 
\emph on
intelligenza artificiale
\emph default
.
 Dopo un breve conto alla rovescia, un'opportuna 
\emph on
client RPC
\emph default
 notifica i vari client dell'inizio della partita, iniziando il caricamento
 del livello corretto su tutti i dispositivi.
\end_layout

\begin_layout Standard
Nella versione originale di OrbTail il sistema di creazione delle 
\emph on
lobby 
\emph default
era esplicito: l'utente poteva decidere se creare un nuovo match oppure
 se partecipare ad uno esistente.
 Questo tipo d'interazione è stato rivisto perchè giudicato obsoleto: nel
 caso in cui non vi fosse nessuna 
\emph on
lobby 
\emph default
disponibile, l'utente era costretto a ritornare al menú principale per crearne
 una e ció aumentava ingiustificatamente il numero di interazioni necessarie
 per entrare in partita.
 Sebbene i flussi di creazione di una paritita online ed offline sono identici,
 la selezione di una o dell'altra modalitá deve essere esplicitamente dichiarata
 dal giocatore all'inizio del flusso di gioco.
 Per questa iterazione era stato valutato un sistema che avrebbe permesso
 al giocatore di entrare in partita e lasciare che il sistema decidesse
 se avviare una partita online o offline (a seconda se vi fosse una connessione
 Internet o meno), tuttavia controllare lo stato della connessione comportava
 lunghe attese e, per ragioni di tempo e mancanza di una soluzione giudicata
 soddisfacente, questa funzionalitá è stata rimandata a sviluppi futuri.
\end_layout

\begin_layout Subsection
Gestione della partita
\end_layout

\begin_layout Standard
La gestione dello stato di gioco è affidata ad un oggetto 
\emph on
GameMode
\emph default
 il cui tipo, derivato dalla classe 
\emph on
BaseGameMode
\emph default
, dipende dalla modalitá di gioco selezionata (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GameModes"

\end_inset

)
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/raffa/Documents/Repo/OrbTail/Doc/Tesi/img/game_modes.jpg
	lyxscale 20
	width 12cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Modalita di gioco
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:GameModes"

\end_inset

Modalitá di gioco
\end_layout

\end_inset


\end_layout

\end_inset

.
 Questo oggetto descrive le regole di gioco e le condizioni di vittoria,
 gestendo al contempo il flusso di gara.
 Tra i suoi parametri di configurazione troviamo la durata massima della
 partita, il numero di punti guadagnati per 
\emph on
orb 
\emph default
collezionato, il numero di 
\emph on
orb 
\emph default
iniziali e cosí via.
 Lo stato di gioco è replicato internamente dalla classe e notificato attraverso
 eventi al quale 
\emph on
osservatori
\emph default
, quali HUD e i veicoli, possono registrarsi e reagire.
 La classe base 
\emph on
BaseGameMode
\emph default
 contiene tutte le logiche condivise tra le varie modalitá, mentre le sue
 derivate ne possono estendere il comportamento implementando logiche specifiche
, come ad esempio il calcolo dei punti e la gestione dell'eliminazione dei
 partecipanti.
 Questo oggetto viene creato dal 
\emph on
server 
\emph default
in fase di creazione della 
\emph on
lobby
\emph default
 e replicato su tutti i client e rimane in vita per tutta la durata della
 partita.
 La gestione degli eventi di gioco quali l'acquisizione o la perdita di
 
\emph on
orb 
\emph default
e 
\emph on
potenziamenti, 
\emph default
è gestita direttamente dal 
\emph on
server
\emph default
 e i 
\emph on
client
\emph default
 ne subiscono passivamente gli esiti attraverso opportuni eventi propagati
 tramite 
\emph on
client RPC.

\emph default
 Gli stati di gioco 
\emph on
non critici
\emph default
 quali tempo rimanente e punteggi sono invece sia calcolati sul server e
 
\emph on
replicati
\emph default
 e sia simulati da tutti i 
\emph on
client 
\emph default
in locale.
 Questa strategia consente a quest'ultimi di osservare sempre una situazione
 verosimile anche in presenza di perdita temporanea della connettivitá
\emph on
.
\end_layout

\begin_layout Standard
Ciascuna partita è strutturata in 
\emph on
quattro 
\emph default
fasi differenti che si susseguono una dopo l'altra fino al termine (Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MatchFlow"

\end_inset

)
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/raffa/Documents/Repo/OrbTail/Doc/Tesi/img/net_flow.jpg
	lyxscale 20
	width 14cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Flusso di gara
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:MatchFlow"

\end_inset

Flusso di gara
\end_layout

\end_inset


\end_layout

\end_inset

.
 Durante la fase iniziale il 
\emph on
server 
\emph default
mette i giocatori in attesa, fintanto che tutti partecipanti abbiano caricato
 la mappa.
 Ogni volta che un dispositivo ha caricato la mappa corretta, il 
\emph on
server
\emph default
 provvede a creare il suo veicolo e a replicarlo: in questo istante il controllo
 del giocatore viene 
\emph on
trasferito 
\emph default
dal 
\emph on
LobbyPlayer 
\emph default
al veicolo, in modo che quest'ultimo possa essere usato per inviare 
\emph on
comandi 
\emph default
al 
\emph on
server
\emph default
 durante la partita.
 L'oggetto 
\emph on
LobbyPlayer 
\emph default
viene preservato in modo da poter contenere informazioni associate al giocatore,
 quali ad esempio il suo 
\emph on
punteggio.

\emph default
 Sull'istanza locale di gioco, l'oggetto 
\emph on
BaseGameMode 
\emph default
determina la creazione di tutti gli oggetti necessari al giocatore che non
 devono essere replicati, quali ad esempio il 
\emph on
controllore della camera
\emph default
 e della 
\emph on
HUD
\emph default
.
 Durante questa breve fase di sincronizzazione, il gioco mostra una breve
 guida che descrive le regole di gioco e tutti i potenziamenti disponibili.
 Questo stratagemma consente sia di ridurre il tempo di attesa percepito
 e sia di informare l'utente delle regole specifiche di gioco.
 Una volta che tutti i partecipanti hanno congedato questa schermata, il
 
\emph on
server 
\emph default
procede con la fase successiva di 
\emph on
conto alla rovescia
\emph default
, lasciando che gli utenti si possano preparare alla sfida.
 La fase successiva è quella di gioco e dura fintanto che il cronometro
 di gara non scende a 
\emph on
zero
\emph default
.
 In questa fase il 
\emph on
server 
\emph default
si occupa di gestire gli scontri trai veicoli e la collezione di oggetti
 e potenziamenti.
 Gli eventi associati a queste gestioni sono propagati attraverso delle
 
\emph on
client RPC
\emph default
.
 La gestione del movimento fa invece eccezione: gli oggetti che rappresentano
 i veicoli dei giocatori sono creati sui rispettivi 
\emph on
client 
\emph default
i quali ne esercitano l'
\emph on
autoritá
\emph default
 determinandone la posizione e la gestione degli input.
 In questo caso il 
\emph on
server 
\emph default
viene usato semplicemente per propagare l'informazione agli altri dispositivi.
 La modalitá di gioco 
\begin_inset Quotes fld
\end_inset

eliminazione
\begin_inset Quotes frd
\end_inset

 prevede inoltre uno stato aggiuntivo che viene abilitato quando il giocatore
 locale viene eliminato dalla partita: in questo stato il giocatore fa da
 
\emph on
spettatore
\emph default
, controllando una camera che puó inquadrare i veicoli dei giocatori rimasti
 in partita e ciclando tra di essi fino a fine partita.
 Al termine del tempo massimo di partita, o quando tutti i giocatori sono
 stati eliminati, il sistema si porta nella fase finale in cui viene dichiarato
 il vincitore a seconda di condizioni specifiche della modalitá di gioco.
 In questa fase è possibile controllare l'esito della partita e abbandonarla,
 ritornando al al menú principale.
 L'abbandono di una partita causa la distruzione completa di tutti gli oggetti
 coinvolti, quali la 
\emph on
lobby
\emph default
, i 
\emph on
veicoli
\emph default
, il 
\emph on
GameMode 
\emph default
e il 
\emph on
LobbyManager
\emph default
.
\end_layout

\begin_layout Standard
In questa nuova iterazione, la gestione delle modalitá online ed offline
 é stata uniformata in modo da seguire lo stesso flusso e basarsi sulle
 stesse classi, evitando gestioni specifiche.
 Secondo quest'ottica le modalitá 
\emph on
offline 
\emph default
sono gestite come fossero delle partite 
\emph on
online 
\emph default
in cui vi sono solo giocatori locali e veicoli gestiti dalla 
\emph on
IA
\emph default
.
 Una limitazione di questo approccio è data dal fatto che in modalitá 
\emph on
online
\emph default
 il motore non supporta la replicazione di oggetti giá posizionati in scena
 e si é pertanto costretti a crearli dinamicamente.
 Per ovviare a questa limitazione è stato creato un 
\emph on
game object 
\emph default
apposito, detto 
\emph on
NetworkSpawner
\emph default
, il quale puó essere posizionato direttamente in scena e configurato con
 un riferimento ad un'altro 
\emph on
game object
\emph default
.
 Durante la creazione del 
\emph on
server 
\emph default
questo 
\emph on
script
\emph default
 si attiva, causando la generazione del 
\emph on
game object 
\emph default
replicato su tutti i client.
 Questo oggetto è stato usato principalmente per gestire gli 
\emph on
orb 
\emph default
e i 
\emph on
core 
\emph default
in quanto le loro posizioni sono configurate manualmente su tutte le piste.
\end_layout

\begin_layout Section
Potenziamenti
\end_layout

\begin_layout Standard
Gestione dei potenziamenti con riguardo per la parte online e di sincronizzazion
e.
\end_layout

\begin_layout Section
Intelligenza artificiale
\end_layout

\begin_layout Section
Splitscreen
\end_layout

\begin_layout Section
Gestione degli input
\end_layout

\begin_layout Section
Menú
\end_layout

\end_body
\end_document
